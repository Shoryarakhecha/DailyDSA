medium -->516. Longest Palindromic Subsequence--->

recursive solution ---> O((2^N)âˆ—N) --> not optimized gives you TLE
class Solution {
    private boolean isPalindromic(StringBuilder sb){
        String str = sb.toString();
        int i = 0, j = str.length() - 1;
        while (i <= j) {
            if (str.charAt(i) != str.charAt(j)) return false;
            i++; j--;
        }
        return true;
    }

    private void helper(String s, int i, StringBuilder sb, int[] ans){
        if (i == s.length()) {
            if (isPalindromic(sb)) {
                ans[0] = Math.max(ans[0], sb.length());
            }
            return;
        }
        sb.append(s.charAt(i));
        helper(s, i + 1, sb, ans);
        sb.deleteCharAt(sb.length() - 1);
        helper(s, i + 1, sb, ans);
    }

    public int longestPalindromeSubseq(String s) {
        int[] ans = new int[]{0};
        helper(s, 0, new StringBuilder(), ans);
        return ans[0];
    }
}
dp solution ---> optimized 
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n=s.length();
    
        String s1="";
        for(int i=n-1;i>=0;i--){
            s1+=s.charAt(i);
        }
        int dp[][]=new int [n+1][n+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(s.charAt(i-1)==s1.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n][n];
    }
}


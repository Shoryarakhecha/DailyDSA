Count Inversions

class Solution {
    int count = 0;

    public void merge(int arr[], int i, int j, int mid) {  
        int n1 = mid - i + 1;
        int n2 = j - mid;
        int l[] = new int[n1];
        int r[] = new int[n2];
        for(int a = 0; a < n1; a++){
            l[a] = arr[i + a];      
        }
        for(int b = 0; b < n2; b++){
            r[b] = arr[mid + 1 + b]; 
        }
        
        int lIndx = 0, rIndx = 0; 
        int k = i;
        while(lIndx < n1 && rIndx < n2){
            if(l[lIndx] <= r[rIndx]){
                arr[k++] = l[lIndx++];
            } else {
                count += (n1 - lIndx);
                arr[k++] = r[rIndx++];
            }
        }
        while(lIndx < n1){
            arr[k++] = l[lIndx++];
        }
        while(rIndx < n2){
            arr[k++] = r[rIndx++];
        }
    }
    
    public void divide(int arr[], int i, int j){
        if(i < j){
            int mid = i + (j - i) / 2;
            divide(arr, i, mid);
            divide(arr, mid + 1, j);
            merge(arr, i, j, mid);
        }
    }

    static int inversionCount(int arr[]) {
        Solution sol = new Solution();
        sol.divide(arr, 0, arr.length - 1);
        return sol.count;
    }
}

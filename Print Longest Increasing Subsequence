Print Longest Increasing Subsequence
it will give answer  but not in lexicographical order of their indices, not optimized
class Solution {
    public ArrayList<Integer>ans=new ArrayList<>();
    public void helper(int arr[],int indx,int prev_indx,ArrayList<Integer>li){
        if(indx==arr.length){
            if(li.size()>ans.size()){
                ans=new ArrayList<>(li);
            }
            
            return;
        }
        helper(arr,indx+1,prev_indx,li);
        if(prev_indx==-1 || arr[indx]>arr[prev_indx]){
            li.add(arr[indx]);
            helper(arr,indx+1,indx,li);
            li.remove(li.size()-1);
        }
    }
    public ArrayList<Integer> getLIS(int arr[]) {
        // Code here
        
        helper(arr,0,-1,new ArrayList<>());
        return ans;
        
    }
}

----->optimized and  in lexicographical order of their indices,
import java.util.*;

class Solution {
    public ArrayList<Integer> getLIS(int arr[]) {
        int n = arr.length;
        int[] dp = new int[n];
        Arrays.fill(dp, 1); 
        
        int[] hash = new int[n];
        for(int i = 0; i < n; i++) {
            hash[i] = i; 
        }
        
        int maxi = 1;
        int lastIndex = 0;
        
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < i; j++) { 
                
                if(arr[j] < arr[i] && 1 + dp[j] > dp[i]) {
                    dp[i] = 1 + dp[j];
                    hash[i] = j; 
                }
            }
            
            if(dp[i] > maxi) {
                maxi = dp[i];
                lastIndex = i;
            }
        }
        
        ArrayList<Integer> ans = new ArrayList<>();
        ans.add(arr[lastIndex]);
        
        while(hash[lastIndex] != lastIndex) {
            lastIndex = hash[lastIndex];
            ans.add(arr[lastIndex]);
        }
        
        Collections.reverse(ans);
        
        return ans;
    }
}
